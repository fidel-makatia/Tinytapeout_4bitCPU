<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nibble — 4-bit CPU Workshop | TinyTapeout IHP</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.1.0/reveal.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.1.0/theme/black.min.css" id="theme">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.1.0/plugin/highlight/monokai.min.css">
<style>
  :root { --r-heading-font: 'Courier New', monospace; }
  .reveal { font-size: 28px; }
  .reveal h1 { font-size: 2.2em; color: #58a6ff; }
  .reveal h2 { font-size: 1.6em; color: #58a6ff; }
  .reveal h3 { font-size: 1.2em; color: #79c0ff; }
  .reveal pre { font-size: 0.55em; width: 95%; }
  .reveal pre code { max-height: 520px; }
  .reveal .small { font-size: 0.7em; }
  .reveal .tiny  { font-size: 0.55em; }
  .reveal table { font-size: 0.65em; margin: 0 auto; }
  .reveal table th { background: #21262d; color: #58a6ff; }
  .reveal table td, .reveal table th { padding: 4px 12px; border: 1px solid #30363d; }
  .reveal .highlight-blue { color: #58a6ff; }
  .reveal .highlight-green { color: #3fb950; }
  .reveal .highlight-yellow { color: #d29922; }
  .reveal .highlight-red { color: #f85149; }
  .reveal .two-col { display: flex; gap: 40px; align-items: flex-start; }
  .reveal .two-col > * { flex: 1; }
  .reveal .box { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 16px; margin: 8px 0; }
  .reveal .box-blue { border-color: #58a6ff; }
  .reveal .box-green { border-color: #3fb950; }
  .reveal .section-slide { background: linear-gradient(135deg, #0d1117 0%, #161b22 100%); }
  .reveal .title-slide h1 { font-size: 2.8em; }
  .reveal .emoji { font-size: 1.5em; }
  .reveal ul { text-align: left; }
  .reveal ol { text-align: left; }
  .reveal blockquote { background: #161b22; border-left: 4px solid #58a6ff; padding: 12px 20px; font-style: normal; }
</style>
</head>
<body>
<div class="reveal">
<div class="slides">

<!-- ============================================================ -->
<!-- TITLE -->
<!-- ============================================================ -->
<section class="title-slide" data-background-gradient="linear-gradient(135deg, #0d1117, #161b22)">
  <h1>Nibble</h1>
  <h3>Building a 4-bit CPU for Real Silicon</h3>
  <p><span class="highlight-blue">TinyTapeout IHP &bull; SG13G2 130nm</span></p>
  <p class="small" style="margin-top: 2em;">Fidel Makatia</p>
  <p class="tiny" style="color: #8b949e;">
    Workshop Materials &bull;
    <a href="https://github.com/fidel-makatia/Tinytapeout_4bitCPU">github.com/fidel-makatia/Tinytapeout_4bitCPU</a>
  </p>
</section>

<!-- ============================================================ -->
<!-- AGENDA -->
<!-- ============================================================ -->
<section>
  <h2>Workshop Agenda</h2>
  <div class="two-col">
    <div>
      <div class="box box-blue">
        <h3>Part 1: Architecture</h3>
        <ul>
          <li>What is a CPU?</li>
          <li>Nibble's ISA (16 instructions)</li>
          <li>Block diagram walkthrough</li>
        </ul>
      </div>
      <div class="box box-blue">
        <h3>Part 2: RTL Design</h3>
        <ul>
          <li>Verilog building blocks</li>
          <li>Fetch-Execute pipeline</li>
          <li>The ALU and registers</li>
        </ul>
      </div>
    </div>
    <div>
      <div class="box box-green">
        <h3>Part 3: Simulation</h3>
        <ul>
          <li>Testbench + waveforms</li>
          <li>Writing programs in binary</li>
          <li>51 automated tests</li>
        </ul>
      </div>
      <div class="box box-green">
        <h3>Part 4: Silicon</h3>
        <ul>
          <li>Synthesis to IHP cells</li>
          <li>Gate-level verification</li>
          <li>TinyTapeout submission</li>
        </ul>
      </div>
    </div>
  </div>
</section>

<!-- ============================================================ -->
<!-- PART 1: ARCHITECTURE -->
<!-- ============================================================ -->
<section class="section-slide">
  <h1>Part 1</h1>
  <h2>CPU Architecture</h2>
</section>

<section>
  <h2>What is a CPU?</h2>
  <div class="two-col">
    <div>
      <p>A CPU is a machine that:</p>
      <ol>
        <li class="fragment"><span class="highlight-blue">FETCH</span> — reads an instruction from memory</li>
        <li class="fragment"><span class="highlight-green">DECODE</span> — figures out what to do</li>
        <li class="fragment"><span class="highlight-yellow">EXECUTE</span> — does the operation</li>
        <li class="fragment"><span class="highlight-red">REPEAT</span> — moves to next instruction</li>
      </ol>
    </div>
    <div class="fragment">
      <div class="box">
        <p class="small">Our CPU does this in <strong>2 clock cycles</strong>:</p>
        <pre><code>Cycle 1: FETCH + DECODE
Cycle 2: EXECUTE

→ 500,000 instructions/sec @ 1 MHz</code></pre>
      </div>
    </div>
  </div>
</section>

<section>
  <h2>Why 4 Bits?</h2>
  <div class="two-col">
    <div>
      <ul>
        <li>Small enough to <strong>fully understand</strong></li>
        <li>Can count <span class="highlight-blue">0 to 15</span></li>
        <li>Only <span class="highlight-green">194 standard cells</span></li>
        <li>Fits in <span class="highlight-yellow">15%</span> of a TinyTapeout tile</li>
        <li>Same principles as a real 64-bit CPU!</li>
      </ul>
    </div>
    <div>
      <div class="box">
        <p class="small"><strong>The constraint:</strong></p>
        <ul class="small">
          <li>TinyTapeout tile: 167 x 108 um</li>
          <li>Max ~1000 standard cells</li>
          <li>IHP SG13G2 130nm PDK</li>
          <li>8 inputs, 8 outputs, 8 bidirectional</li>
        </ul>
      </div>
    </div>
  </div>
</section>

<section>
  <h2>Architecture at a Glance</h2>
  <div class="box">
    <table>
      <tr><th>Feature</th><th>Nibble CPU</th></tr>
      <tr><td>Architecture</td><td>Harvard (separate code &amp; data)</td></tr>
      <tr><td>Data width</td><td>4 bits</td></tr>
      <tr><td>Instruction width</td><td>8 bits (4 opcode + 4 immediate)</td></tr>
      <tr><td>Registers</td><td>Accumulator (A), Program Counter (PC), Instruction Register (IR)</td></tr>
      <tr><td>Flags</td><td>Carry (C), Zero (Z)</td></tr>
      <tr><td>Instructions</td><td>16 (see ISA table)</td></tr>
      <tr><td>Address space</td><td>16 locations (4-bit PC)</td></tr>
      <tr><td>Pipeline</td><td>2-cycle fetch-execute</td></tr>
    </table>
  </div>
</section>

<section>
  <h2>Block Diagram</h2>
  <pre><code class="language-plaintext" style="font-size: 0.85em;">                    TinyTapeout IHP Chip
  ┌──────────────────────────────────────────────────────┐
  │  ui_in[7:0] ──────────┐                              │
  │  (instruction)        │                              │
  │                   ┌───▼───┐    ┌────────────┐        │
  │                   │  IR   │───►│  OPCODE    │        │
  │                   │ 8-bit │    │  DECODER   │        │
  │                   └───────┘    └─────┬──────┘        │
  │                                      │ control       │
  │                   ┌───────┐    ┌─────▼────┐          │
  │  uio[7:4] ──────►│  MUX  │───►│   ALU    │          │
  │  (input port)     │ 4-bit │    │  4-bit   │          │
  │                   └───────┘    └──┬───┬───┘          │
  │                   ┌────────┐      │   │              │
  │                   │  ACC   │◄─────┘   │flags         │
  │                   │ 4-bit  │──────────┼──► uo_out    │
  │                   └────────┘     ┌────▼────┐         │
  │                   ┌────────┐     │ BRANCH  │         │
  │                   │   PC   │◄────┤  LOGIC  │         │
  │                   │ 4-bit  │     └─────────┘         │
  │                   └───┬────┘                         │
  │                       └──────────────────► uio[3:0]  │
  └──────────────────────────────────────────────────────┘</code></pre>
</section>

<!-- ============================================================ -->
<!-- INSTRUCTION SET -->
<!-- ============================================================ -->
<section>
  <h2>Instruction Set Architecture</h2>
  <p class="small">8-bit instruction: <code>[7:4] = opcode</code>, <code>[3:0] = immediate/address</code></p>
  <table style="font-size: 0.55em;">
    <tr><th>Opcode</th><th>Hex</th><th>Mnemonic</th><th>Operation</th><th>Flags</th></tr>
    <tr><td>0000</td><td>0x0</td><td>NOP</td><td>No operation</td><td>—</td></tr>
    <tr><td>0001</td><td>0x1</td><td>LDI imm</td><td>A = imm</td><td>Z</td></tr>
    <tr><td>0010</td><td>0x2</td><td>ADD imm</td><td>A = A + imm</td><td>C, Z</td></tr>
    <tr><td>0011</td><td>0x3</td><td>SUB imm</td><td>A = A - imm</td><td>C, Z</td></tr>
    <tr><td>0100</td><td>0x4</td><td>AND imm</td><td>A = A &amp; imm</td><td>Z</td></tr>
    <tr><td>0101</td><td>0x5</td><td>OR imm</td><td>A = A | imm</td><td>Z</td></tr>
    <tr><td>0110</td><td>0x6</td><td>XOR imm</td><td>A = A ^ imm</td><td>Z</td></tr>
    <tr><td>0111</td><td>0x7</td><td>NOT</td><td>A = ~A</td><td>Z</td></tr>
    <tr><td>1000</td><td>0x8</td><td>SHL</td><td>{C,A} = {A[3], A&lt;&lt;1}</td><td>C, Z</td></tr>
    <tr><td>1001</td><td>0x9</td><td>SHR</td><td>{A,C} = {A&gt;&gt;1, A[0]}</td><td>C, Z</td></tr>
    <tr><td>1010</td><td>0xA</td><td>JMP addr</td><td>PC = addr</td><td>—</td></tr>
    <tr><td>1011</td><td>0xB</td><td>JZ addr</td><td>if Z: PC = addr</td><td>—</td></tr>
    <tr><td>1100</td><td>0xC</td><td>JC addr</td><td>if C: PC = addr</td><td>—</td></tr>
    <tr><td>1101</td><td>0xD</td><td>JNZ addr</td><td>if !Z: PC = addr</td><td>—</td></tr>
    <tr><td>1110</td><td>0xE</td><td>IN</td><td>A = input_port</td><td>Z</td></tr>
    <tr><td>1111</td><td>0xF</td><td>HLT</td><td>Halt CPU</td><td>—</td></tr>
  </table>
</section>

<section>
  <h2>Instruction Encoding</h2>
  <div class="two-col">
    <div>
      <pre><code class="language-plaintext">  8-bit instruction word
  ┌────────────────────────┐
  │ 7  6  5  4 │ 3  2  1  0│
  │   OPCODE   │ IMMEDIATE │
  └────────────┴───────────┘

  Example: ADD 5
  Opcode = 0010 (ADD)
  Imm    = 0101 (5)

  Binary: 0010 0101
  Hex:    0x25</code></pre>
    </div>
    <div>
      <div class="box">
        <p><strong>Encode these:</strong></p>
        <ol class="small">
          <li>LDI 7 → <span class="fragment highlight-green">0001 0111 = 0x17</span></li>
          <li>SUB 3 → <span class="fragment highlight-green">0011 0011 = 0x33</span></li>
          <li>JMP 0 → <span class="fragment highlight-green">1010 0000 = 0xA0</span></li>
          <li>HLT   → <span class="fragment highlight-green">1111 0000 = 0xF0</span></li>
        </ol>
      </div>
    </div>
  </div>
</section>

<!-- ============================================================ -->
<!-- PART 2: RTL DESIGN -->
<!-- ============================================================ -->
<section class="section-slide">
  <h1>Part 2</h1>
  <h2>RTL Design in Verilog</h2>
</section>

<section>
  <h2>Verilog Crash Course</h2>
  <div class="two-col">
    <div>
      <div class="box box-blue">
        <h3>Combinational (wires)</h3>
        <pre><code class="language-verilog">// AND gate
assign y = a & b;

// Multiplexer
assign out = sel ? in1 : in0;

// Always block
always @(*) begin
  if (opcode == 4'h2)
    result = a + b;
  else
    result = a;
end</code></pre>
      </div>
    </div>
    <div>
      <div class="box box-green">
        <h3>Sequential (registers)</h3>
        <pre><code class="language-verilog">// D flip-flop with reset
always @(posedge clk or negedge rst_n)
  if (!rst_n)
    acc <= 4'b0000;
  else
    acc <= next_acc;

// Counter
always @(posedge clk)
  if (enable)
    count <= count + 1;</code></pre>
      </div>
    </div>
  </div>
</section>

<section>
  <h2>Register File: 20 Flip-Flops</h2>
  <p class="small">All CPU state is stored in D flip-flops with async active-low reset</p>
  <pre><code class="language-plaintext">  ┌──────────────────────────────────────────────┐
  │            REGISTER FILE (20 DFFs)           │
  │                                              │
  │  ACC[3:0]    4 x DFF ──► uo_out[3:0]       │
  │  PC[3:0]     4 x DFF ──► uio_out[3:0]      │
  │  IR[7:0]     8 x DFF     (internal)         │
  │  carry       1 x DFF ──► uo_out[4]          │
  │  zero        1 x DFF ──► uo_out[5]          │
  │  halted      1 x DFF ──► uo_out[6]          │
  │  phase       1 x DFF ──► uo_out[7]          │
  │                                              │
  │  Total: 4+4+8+1+1+1+1 = 20 flip-flops      │
  └──────────────────────────────────────────────┘

  Each DFF: ┌─────────┐
            │  D    Q ├──► output
            │ CLK    ─┤◄── clk
            │ RST_B ─┤◄── rst_n (Q=0 when RST_B=0)
            └─────────┘</code></pre>
</section>

<section>
  <h2>Fetch-Execute FSM</h2>
  <div class="two-col">
    <div>
      <pre><code class="language-plaintext">  ┌─────────┐       ┌─────────────┐
  │  FETCH  │──────►│  EXECUTE    │
  │ phase=0 │       │  phase=1    │
  │         │◄──────│             │
  └─────────┘       └─────────────┘

  FETCH (phase=0):
   IR <= ui_in[7:0]
   phase <= 1

  EXECUTE (phase=1):
   ACC   <= ALU result
   PC    <= next_pc
   carry <= next_carry
   zero  <= next_zero
   phase <= 0</code></pre>
    </div>
    <div>
      <pre><code class="language-plaintext">Timing Diagram:

clk   ╱╲__╱╲__╱╲__╱╲__╱╲__╱╲__
phase __0____1____0____1____0__
action FETCH EXEC  FETCH EXEC
        instr0      instr1
PC out  0           1
ACC     ----  res0  ---- res1</code></pre>
      <div class="box small">
        <p>Only <strong>1 flip-flop</strong> controls the entire pipeline!</p>
        <p><code>phase = 0</code> → Fetch<br><code>phase = 1</code> → Execute</p>
      </div>
    </div>
  </div>
</section>

<section>
  <h2>The ALU</h2>
  <pre><code class="language-plaintext">  ┌─────────────────────────────────────────────┐
  │                  4-BIT ALU                   │
  │                                              │
  │  ACC[3:0] ──►┌──────┐                       │
  │              │ ADDER│──► sum[3:0]  ──┐      │
  │  imm[3:0] ──►│      │──► cout      ──┤      │
  │              └──────┘                │      │
  │  ACC ──► AND ──► and[3:0] ──────────┤      │
  │  imm ──► AND                        │      │
  │                                ┌────▼────┐ │
  │  ACC ──► OR  ──► or[3:0]  ───►│ RESULT  │ │
  │  ACC ──► XOR ──► xor[3:0] ───►│  MUX    │─► next_acc
  │  ACC ──► NOT ──► not[3:0] ───►│(opcode) │─► next_carry
  │  ACC ──► SHL ──► shl[3:0] ───►│         │─► next_zero
  │  ACC ──► SHR ──► shr[3:0] ───►│         │ │
  │  port_in ─────► in[3:0]  ───►│         │ │
  │  imm ─────────► ldi[3:0] ───►│         │ │
  │                                └─────────┘ │
  │  Zero detect: NOR(result[3:0]) ──► Z       │
  └─────────────────────────────────────────────┘</code></pre>
</section>

<section>
  <h2>Full Adder — Gate Level</h2>
  <div class="two-col">
    <div>
      <pre><code class="language-plaintext">  Full Adder (1-bit):

  A ──┬──►XOR──┬──►XOR──► Sum
  B ──┘        │    ▲
               │   Cin
  A ──┬──►AND──┘
  B ──┘        ├──►OR ──► Cout
  Cin─┬──►AND──┘
  A^B─┘

  4-bit Ripple Carry Adder:

  ┌────┐  ┌────┐  ┌────┐  ┌────┐
  │ FA │──│ FA │──│ FA │──│ FA │─►Cout
  │[0] │  │[1] │  │[2] │  │[3] │
  └──┬─┘  └──┬─┘  └──┬─┘  └──┬─┘
     ▼       ▼       ▼       ▼
  sum[0]  sum[1]  sum[2]  sum[3]</code></pre>
    </div>
    <div>
      <div class="box">
        <h3>Truth Table</h3>
        <table style="font-size: 0.55em;">
          <tr><th>A</th><th>B</th><th>Cin</th><th>Sum</th><th>Cout</th></tr>
          <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
          <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
          <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
          <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
          <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
          <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
          <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
          <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
        </table>
        <p class="tiny" style="margin-top:8px;">Sum = A XOR B XOR Cin<br>Cout = (A AND B) OR (Cin AND (A XOR B))</p>
      </div>
    </div>
  </div>
</section>

<section>
  <h2>Branch Logic</h2>
  <pre><code class="language-plaintext">  ┌───────────────────────────────────────────┐
  │             BRANCH LOGIC                  │
  │                                           │
  │   is_JMP ────────────────────►OR──┐       │
  │                                   │       │
  │   is_JZ  ──►AND──┐              │       │
  │   zero ────►AND──┴───────────────►OR──┐   │
  │                                       │   │
  │   is_JC  ──►AND──┐                  │   │
  │   carry ───►AND──┴───────────────────►OR──┤
  │                                           │
  │   is_JNZ ──►AND──┐                      │
  │   ~zero ───►AND──┴───────────────────────┤
  │                               take_branch │
  │                                           ▼
  │   ┌───────────┐            ┌──────────────┐
  │   │  PC + 1   │───────────►│    MUX       │──► next_pc
  │   └───────────┘            │ 0: PC+1      │
  │                            │ 1: imm[3:0]  │
  │   imm[3:0] ──────────────►│ sel: branch  │
  │                            └──────────────┘
  └───────────────────────────────────────────┘</code></pre>
</section>

<section>
  <h2>The Verilog — cpu_core.v</h2>
  <pre><code class="language-verilog" style="font-size: 0.48em;">module cpu_core (
    input  wire       clk,
    input  wire       rst_n,
    input  wire [7:0] instr_data,   // from external program memory
    input  wire [3:0] port_in,      // 4-bit input port
    output wire [3:0] pc_out,       // program counter → address bus
    output wire [3:0] acc_out,      // accumulator → visible result
    output wire       carry_out, zero_out, halted_out, phase_out
);
    // State
    reg [3:0] acc, pc;
    reg [7:0] ir;
    reg       carry, zero, halted, phase;

    // Decode
    wire [3:0] opcode = ir[7:4];
    wire [3:0] imm    = ir[3:0];

    // ALU (combinational) — computes ALL results, MUX selects
    always @(*) begin
        case (opcode)
            4'h1: {next_carry, next_acc} = {carry, imm};          // LDI
            4'h2: {next_carry, next_acc} = acc + imm;             // ADD
            4'h3: {next_carry, next_acc} = acc - imm;             // SUB
            4'h4: {next_carry, next_acc} = {carry, acc & imm};    // AND
            // ... OR, XOR, NOT, SHL, SHR, IN ...
        endcase
    end

    // FSM (sequential)
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            acc<=0; pc<=0; ir<=0; carry<=0; zero<=0; halted<=0; phase<=0;
        end else if (!halted) begin
            if (phase == 0) begin ir <= instr_data; phase <= 1; end
            else begin acc<=next_acc; pc<=next_pc; /*...*/ phase<=0; end
        end
    end
endmodule</code></pre>
  <p class="small">Full source: <code>src/cpu_core.v</code> (219 lines)</p>
</section>

<section>
  <h2>TinyTapeout Wrapper</h2>
  <pre><code class="language-verilog" style="font-size: 0.52em;">module tt_um_fidel_makatia_4bit_cpu (
    input  wire       clk,        // System clock
    input  wire       rst_n,      // Active-low reset
    input  wire       ena,        // Design enable
    input  wire [7:0] ui_in,      // 8 input pins  → instruction word
    output wire [7:0] uo_out,     // 8 output pins → acc + flags
    input  wire [7:0] uio_in,     // Bidir input   → input port [7:4]
    output wire [7:0] uio_out,    // Bidir output  → program counter [3:0]
    output wire [7:0] uio_oe      // Bidir enable  → 0x0F (lower = output)
);
    cpu_core core (
        .clk(clk), .rst_n(rst_n),
        .instr_data(ui_in),              // instruction from pins
        .port_in(uio_in[7:4]),           // input port (upper nibble)
        .pc_out(uio_out[3:0]),           // PC → lower nibble out
        .acc_out(uo_out[3:0]),           // accumulator → output
        .carry_out(uo_out[4]),           // flags on remaining bits
        .zero_out(uo_out[5]),
        .halted_out(uo_out[6]),
        .phase_out(uo_out[7])
    );
    assign uio_oe = 8'b0000_1111;       // lower 4 = output, upper 4 = input
    assign uio_out[7:4] = 4'b0000;
endmodule</code></pre>
</section>

<!-- ============================================================ -->
<!-- PIN MAPPING -->
<!-- ============================================================ -->
<section>
  <h2>TinyTapeout Pin Mapping</h2>
  <div class="two-col">
    <div>
      <div class="box box-blue">
        <h3>Inputs (ui_in)</h3>
        <table style="font-size: 0.5em;">
          <tr><th>Pin</th><th>Signal</th></tr>
          <tr><td>ui_in[7]</td><td>Opcode MSB</td></tr>
          <tr><td>ui_in[6]</td><td>Opcode bit 6</td></tr>
          <tr><td>ui_in[5]</td><td>Opcode bit 5</td></tr>
          <tr><td>ui_in[4]</td><td>Opcode LSB</td></tr>
          <tr><td>ui_in[3]</td><td>Immediate MSB</td></tr>
          <tr><td>ui_in[2]</td><td>Immediate bit 2</td></tr>
          <tr><td>ui_in[1]</td><td>Immediate bit 1</td></tr>
          <tr><td>ui_in[0]</td><td>Immediate LSB</td></tr>
        </table>
      </div>
    </div>
    <div>
      <div class="box box-green">
        <h3>Outputs (uo_out)</h3>
        <table style="font-size: 0.5em;">
          <tr><th>Pin</th><th>Signal</th></tr>
          <tr><td>uo_out[3:0]</td><td>Accumulator (result)</td></tr>
          <tr><td>uo_out[4]</td><td>Carry flag</td></tr>
          <tr><td>uo_out[5]</td><td>Zero flag</td></tr>
          <tr><td>uo_out[6]</td><td>Halted</td></tr>
          <tr><td>uo_out[7]</td><td>Phase (fetch/exec)</td></tr>
        </table>
      </div>
      <div class="box" style="border-color: #d29922;">
        <h3>Bidirectional (uio)</h3>
        <table style="font-size: 0.5em;">
          <tr><th>Pin</th><th>Dir</th><th>Signal</th></tr>
          <tr><td>uio[3:0]</td><td>OUT</td><td>Program Counter</td></tr>
          <tr><td>uio[7:4]</td><td>IN</td><td>Input port</td></tr>
        </table>
      </div>
    </div>
  </div>
</section>

<!-- ============================================================ -->
<!-- PART 3: SIMULATION -->
<!-- ============================================================ -->
<section class="section-slide">
  <h1>Part 3</h1>
  <h2>Simulation &amp; Testing</h2>
</section>

<section>
  <h2>Example: Counter Program</h2>
  <div class="two-col">
    <div>
      <table style="font-size: 0.6em;">
        <tr><th>Addr</th><th>Hex</th><th>Binary</th><th>ASM</th><th>What it does</th></tr>
        <tr><td>0x0</td><td>0x10</td><td>0001 0000</td><td>LDI 0</td><td>A = 0</td></tr>
        <tr><td>0x1</td><td>0x21</td><td>0010 0001</td><td>ADD 1</td><td>A = A + 1</td></tr>
        <tr><td>0x2</td><td>0xD1</td><td>1101 0001</td><td>JNZ 1</td><td>Loop if A != 0</td></tr>
        <tr><td>0x3</td><td>0xF0</td><td>1111 0000</td><td>HLT</td><td>Stop</td></tr>
      </table>
    </div>
    <div class="fragment">
      <div class="box">
        <p class="small"><strong>Execution trace:</strong></p>
        <pre><code class="language-plaintext" style="font-size: 0.85em;">A = 0  → ADD 1 → A = 1  → JNZ 1 ✓
A = 1  → ADD 1 → A = 2  → JNZ 1 ✓
A = 2  → ADD 1 → A = 3  → JNZ 1 ✓
...
A = 14 → ADD 1 → A = 15 → JNZ 1 ✓
A = 15 → ADD 1 → A = 0  → JNZ 1 ✗
→ HLT (counts 0→15→0 then stops)</code></pre>
      </div>
    </div>
  </div>
</section>

<section>
  <h2>Example: Fibonacci</h2>
  <div class="two-col">
    <div>
      <table style="font-size: 0.6em;">
        <tr><th>Addr</th><th>Hex</th><th>ASM</th><th>ACC</th></tr>
        <tr><td>0x0</td><td>0x10</td><td>LDI 0</td><td>0</td></tr>
        <tr><td>0x1</td><td>0x21</td><td>ADD 1</td><td>1</td></tr>
        <tr><td>0x2</td><td>0x20</td><td>ADD 0</td><td>1</td></tr>
        <tr><td>0x3</td><td>0x21</td><td>ADD 1</td><td>2</td></tr>
        <tr><td>0x4</td><td>0x21</td><td>ADD 1</td><td>3</td></tr>
        <tr><td>0x5</td><td>0x22</td><td>ADD 2</td><td>5</td></tr>
        <tr><td>0x6</td><td>0x23</td><td>ADD 3</td><td>8</td></tr>
        <tr><td>0x7</td><td>0x25</td><td>ADD 5</td><td>13</td></tr>
        <tr><td>0x8</td><td>0xF0</td><td>HLT</td><td>—</td></tr>
      </table>
    </div>
    <div>
      <div class="box">
        <p class="small"><strong>Sequence:</strong> 0, 1, 1, 2, 3, 5, 8, <span class="highlight-green">13</span></p>
        <p class="small">Since we only have an accumulator (no second register), each ADD uses an immediate. This means we "hardcode" the previous Fibonacci number as the immediate operand.</p>
        <p class="small fragment"><strong>Challenge:</strong> Can you write a looping Fibonacci using the IN instruction to provide the second operand?</p>
      </div>
    </div>
  </div>
</section>

<section>
  <h2>Example: Shift &amp; Carry</h2>
  <table>
    <tr><th>Addr</th><th>Hex</th><th>ASM</th><th>ACC (binary)</th><th>C</th><th>Z</th></tr>
    <tr><td>0x0</td><td>0x11</td><td>LDI 1</td><td>0001</td><td>0</td><td>0</td></tr>
    <tr class="fragment"><td>0x1</td><td>0x80</td><td>SHL</td><td>0010</td><td>0</td><td>0</td></tr>
    <tr class="fragment"><td>0x2</td><td>0x80</td><td>SHL</td><td>0100</td><td>0</td><td>0</td></tr>
    <tr class="fragment"><td>0x3</td><td>0x80</td><td>SHL</td><td>1000</td><td>0</td><td>0</td></tr>
    <tr class="fragment"><td>0x4</td><td>0x80</td><td>SHL</td><td class="highlight-red">0000</td><td class="highlight-yellow">1</td><td class="highlight-yellow">1</td></tr>
    <tr class="fragment"><td>0x5</td><td>0xF0</td><td>HLT</td><td>—</td><td>—</td><td>—</td></tr>
  </table>
  <p class="fragment small">The MSB "falls off" into the <span class="highlight-yellow">carry flag</span>!</p>
</section>

<section>
  <h2>Running the Testbench</h2>
  <pre><code class="language-bash">$ make test
========== RTL Simulation ==========

========== Test 1: Basic ALU ==========
  PASS: LDI 5 — acc=5, Z=0
  PASS: ADD 3 — acc=8
  PASS: SUB 2 — acc=6
  PASS: AND f — acc=6
  ...

========== Test 4: Counter ==========
  PASS: Counter step 0 — acc=1
  PASS: Counter step 1 — acc=2
  ...
  PASS: Counter reached 0 (wrapped), halted

========== Test 6: Input Port ==========
  PASS: IN — acc=9, read from port

  RESULTS: 51 / 51 passed
  ✓ ALL TESTS PASSED</code></pre>
</section>

<section>
  <h2>Waveform Viewer</h2>
  <pre><code class="language-bash">$ make wave     # Opens GTKWave</code></pre>
  <div class="box">
    <pre><code class="language-plaintext" style="font-size: 0.75em;">  Add these signals to GTKWave:
  ┌─────────────────────────────────────────────────────────┐
  │ Signal     │▁▁╱╲▁▁╱╲▁▁╱╲▁▁╱╲▁▁╱╲▁▁╱╲▁▁╱╲▁▁╱╲▁▁╱╲▁▁│
  ├────────────┼────────────────────────────────────────────┤
  │ clk        │ ╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲╱╲ │
  │ rst_n      │▁▁▁▁╱▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔│
  │ phase      │     0  1  0  1  0  1  0  1  0  1        │
  │ pc[3:0]    │     0     1     2     3     4            │
  │ ir[7:0]    │     10    21    D1    21    D1           │
  │ acc[3:0]   │     0     1     1     2     2            │
  │ carry      │     0     0     0     0     0            │
  │ zero       │     1     0     0     0     0            │
  └────────────┴────────────────────────────────────────────┘</code></pre>
  </div>
  <p class="small">Observe FETCH/EXECUTE alternating. ACC updates on EXECUTE edges.</p>
</section>

<section>
  <h2>Hands-On: Write Your Own Program!</h2>
  <div class="box box-blue">
    <p><strong>Challenge 1:</strong> Write a program that loads 15 and counts DOWN to 0, then halts.</p>
    <p class="tiny fragment">Hint: SUB 1, then JNZ to loop back, then HLT</p>
  </div>
  <div class="box box-green" style="margin-top: 12px;">
    <p><strong>Challenge 2:</strong> Write a program that reads the input port, doubles it (SHL), and halts.</p>
    <p class="tiny fragment">Hint: IN, SHL, HLT — only 3 instructions!</p>
  </div>
  <div class="box" style="border-color: #d29922; margin-top: 12px;">
    <p><strong>Challenge 3:</strong> Write a program that checks if the input is zero. Output 1 if yes, 0 if no.</p>
    <p class="tiny fragment">Hint: IN, JZ to a LDI 1, otherwise LDI 0, then HLT</p>
  </div>
</section>

<!-- ============================================================ -->
<!-- PART 4: SILICON -->
<!-- ============================================================ -->
<section class="section-slide">
  <h1>Part 4</h1>
  <h2>From Code to Silicon</h2>
</section>

<section>
  <h2>The Journey to a Chip</h2>
  <div style="text-align: center; font-size: 0.9em;">
    <div class="fragment" style="display: inline-block; margin: 8px;">
      <div class="box box-blue" style="display: inline-block; padding: 12px 24px;">
        <strong>1. RTL Design</strong><br>
        <span class="small">Verilog code</span>
      </div>
    </div>
    <span class="fragment">→</span>
    <div class="fragment" style="display: inline-block; margin: 8px;">
      <div class="box box-green" style="display: inline-block; padding: 12px 24px;">
        <strong>2. Simulation</strong><br>
        <span class="small">iverilog + testbench</span>
      </div>
    </div>
    <span class="fragment">→</span>
    <div class="fragment" style="display: inline-block; margin: 8px;">
      <div class="box" style="border-color: #d29922; display: inline-block; padding: 12px 24px;">
        <strong>3. Synthesis</strong><br>
        <span class="small">Yosys → gate netlist</span>
      </div>
    </div>
    <br>
    <span class="fragment">→</span>
    <div class="fragment" style="display: inline-block; margin: 8px;">
      <div class="box" style="border-color: #f85149; display: inline-block; padding: 12px 24px;">
        <strong>4. Place &amp; Route</strong><br>
        <span class="small">OpenLane → layout</span>
      </div>
    </div>
    <span class="fragment">→</span>
    <div class="fragment" style="display: inline-block; margin: 8px;">
      <div class="box" style="border-color: #a371f7; display: inline-block; padding: 12px 24px;">
        <strong>5. GDS Export</strong><br>
        <span class="small">Physical masks</span>
      </div>
    </div>
    <span class="fragment">→</span>
    <div class="fragment" style="display: inline-block; margin: 8px;">
      <div class="box" style="border-color: #f0883e; display: inline-block; padding: 12px 24px;">
        <strong>6. Fabrication</strong><br>
        <span class="small">IHP 130nm fab</span>
      </div>
    </div>
  </div>
  <p class="fragment small" style="margin-top: 20px;">We do steps 1-3 locally. Steps 4-5 run automatically in GitHub CI. Step 6 is done by IHP!</p>
</section>

<section>
  <h2>Synthesis: Verilog → Gates</h2>
  <pre><code class="language-bash">$ make synth
========== Synthesis (IHP SG13G2) ==========

   Number of wires:                212
   Number of wire bits:            534
   Number of cells:                194

   Chip area for module: 2677.305600 um²</code></pre>
  <div class="two-col">
    <div class="box">
      <p class="small"><strong>What Yosys does:</strong></p>
      <ol class="small">
        <li>Reads your Verilog</li>
        <li>Maps <code>if/case</code> to MUXes</li>
        <li>Maps <code>+</code> to full adders</li>
        <li>Maps <code>always @(posedge)</code> to DFFs</li>
        <li>Optimizes and maps to IHP cells</li>
      </ol>
    </div>
    <div class="box">
      <p class="small"><strong>Result:</strong></p>
      <ul class="small">
        <li>194 standard cells</li>
        <li>20 flip-flops</li>
        <li>174 logic gates</li>
        <li>2,677 um² area</li>
        <li>~15% of tile utilized</li>
      </ul>
    </div>
  </div>
</section>

<section>
  <h2>IHP SG13G2 Standard Cells</h2>
  <p class="small">Our CPU uses 22 different cell types from the IHP library:</p>
  <div class="two-col">
    <div>
      <table style="font-size: 0.48em;">
        <tr><th>Cell</th><th>Count</th><th>Function</th></tr>
        <tr><td>sg13g2_dfrbpq_1</td><td>20</td><td>D Flip-Flop</td></tr>
        <tr><td>sg13g2_nor2_1</td><td>17</td><td>2-input NOR</td></tr>
        <tr><td>sg13g2_o21ai_1</td><td>15</td><td>OR-AND-INV</td></tr>
        <tr><td>sg13g2_nand2_1</td><td>15</td><td>2-input NAND</td></tr>
        <tr><td>sg13g2_a22oi_1</td><td>15</td><td>AND-OR-INV</td></tr>
        <tr><td>sg13g2_nand3_1</td><td>14</td><td>3-input NAND</td></tr>
        <tr><td>sg13g2_inv_1</td><td>14</td><td>Inverter</td></tr>
        <tr><td>sg13g2_and2_1</td><td>10</td><td>2-input AND</td></tr>
        <tr><td>sg13g2_a21oi_1</td><td>10</td><td>AND-OR-INV</td></tr>
        <tr><td>sg13g2_nor4_1</td><td>9</td><td>4-input NOR</td></tr>
        <tr><td>sg13g2_nand2b_1</td><td>9</td><td>NAND (inv input)</td></tr>
      </table>
    </div>
    <div>
      <table style="font-size: 0.48em;">
        <tr><th>Cell</th><th>Count</th><th>Function</th></tr>
        <tr><td>sg13g2_mux2_1</td><td>8</td><td>2:1 MUX</td></tr>
        <tr><td>sg13g2_xnor2_1</td><td>6</td><td>2-input XNOR</td></tr>
        <tr><td>sg13g2_nor3_1</td><td>6</td><td>3-input NOR</td></tr>
        <tr><td>sg13g2_nand4_1</td><td>6</td><td>4-input NAND</td></tr>
        <tr><td>sg13g2_a221oi_1</td><td>5</td><td>AND-AND-OR-INV</td></tr>
        <tr><td>sg13g2_xor2_1</td><td>4</td><td>2-input XOR</td></tr>
        <tr><td>sg13g2_nor2b_1</td><td>4</td><td>NOR (inv input)</td></tr>
        <tr><td>sg13g2_nand3b_1</td><td>3</td><td>3-NAND (inv)</td></tr>
        <tr><td>sg13g2_or2_1</td><td>2</td><td>2-input OR</td></tr>
        <tr><td>sg13g2_and4_1</td><td>1</td><td>4-input AND</td></tr>
        <tr><td>sg13g2_and3_1</td><td>1</td><td>3-input AND</td></tr>
      </table>
      <p class="tiny" style="margin-top: 8px;"><strong>Total: 194 cells</strong></p>
    </div>
  </div>
</section>

<section>
  <h2>Gate-Level Verification</h2>
  <pre><code class="language-bash">$ make test_gl
========== Gate-Level Simulation (IHP SG13G2) ==========

  ...same 51 tests...

  RESULTS: 51 / 51 passed
  ✓ ALL TESTS PASSED</code></pre>
  <div class="box">
    <p class="small"><strong>Why gate-level sim matters:</strong></p>
    <ul class="small">
      <li>RTL sim tests your <em>design intent</em></li>
      <li>Gate-level sim tests the <em>actual netlist</em> that goes to silicon</li>
      <li>Catches synthesis tool bugs, timing issues, optimization errors</li>
      <li>51/51 PASS at both levels = high confidence</li>
    </ul>
  </div>
</section>

<section>
  <h2>TinyTapeout Submission</h2>
  <ol>
    <li class="fragment">
      Fork the <a href="https://github.com/TinyTapeout/ttihp-verilog-template">TinyTapeout IHP template</a>
    </li>
    <li class="fragment">
      Copy your source files:
      <pre><code class="language-bash">cp src/project.v src/cpu_core.v src/config.json → src/
cp info.yaml → info.yaml</code></pre>
    </li>
    <li class="fragment">
      Push to GitHub → <strong>CI runs automatically</strong>
      <ul class="small">
        <li>OpenLane synthesizes, places, and routes</li>
        <li>DRC checks pass</li>
        <li>GDS file generated</li>
      </ul>
    </li>
    <li class="fragment">
      Submit at <a href="https://app.tinytapeout.com">app.tinytapeout.com</a>
    </li>
    <li class="fragment">
      <span class="highlight-green"><strong>Wait for your chip to arrive!</strong></span>
    </li>
  </ol>
</section>

<!-- ============================================================ -->
<!-- TOOL INSTALLATION -->
<!-- ============================================================ -->
<section class="section-slide">
  <h1>Tool Setup</h1>
  <h2>Getting Your Environment Ready</h2>
</section>

<section>
  <h2>macOS Setup</h2>
  <pre><code class="language-bash"># 1. Install Homebrew (if needed)
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# 2. Install simulation tools
brew install icarus-verilog        # Verilog simulator
brew install --cask gtkwave        # Waveform viewer

# 3. Install synthesis tool
brew install yosys                 # RTL synthesis

# 4. Install IHP PDK (standard cell library)
cd ~
git clone --depth 1 https://github.com/IHP-GmbH/IHP-Open-PDK.git

# 5. Verify
iverilog -V | head -1
yosys --version
ls ~/IHP-Open-PDK/ihp-sg13g2/</code></pre>
</section>

<section>
  <h2>Windows Setup (WSL2)</h2>
  <pre><code class="language-powershell"># Step 1: Install WSL2 (PowerShell as Administrator)
wsl --install -d Ubuntu-22.04

# Step 2: Restart computer, open "Ubuntu" from Start menu</code></pre>
  <p class="small">Then inside the WSL2 Ubuntu terminal:</p>
  <pre><code class="language-bash"># Follow the Linux instructions (next slide)</code></pre>
  <div class="box small" style="margin-top: 12px;">
    <p><strong>Alternative (no WSL2):</strong> Install MSYS2 from <a href="https://www.msys2.org/">msys2.org</a></p>
    <pre><code class="language-bash">pacman -S mingw-w64-x86_64-iverilog
pacman -S mingw-w64-x86_64-yosys</code></pre>
    <p>Or download the all-in-one <a href="https://github.com/YosysHQ/oss-cad-suite-build/releases">OSS CAD Suite</a></p>
  </div>
</section>

<section>
  <h2>Linux (Ubuntu/Debian) Setup</h2>
  <pre><code class="language-bash"># 1. Install simulation tools
sudo apt update
sudo apt install -y iverilog gtkwave

# 2. Install synthesis tool
sudo apt install -y yosys

# (If yosys is too old, use OSS CAD Suite instead)

# 3. Install IHP PDK
cd ~
git clone --depth 1 https://github.com/IHP-GmbH/IHP-Open-PDK.git

# 4. Verify everything works
iverilog -V | head -1
yosys --version
ls ~/IHP-Open-PDK/ihp-sg13g2/</code></pre>
</section>

<section>
  <h2>Verify Your Setup</h2>
  <pre><code class="language-bash"># Clone the repo
git clone https://github.com/fidel-makatia/Tinytapeout_4bitCPU.git
cd Tinytapeout_4bitCPU

# RTL simulation (works everywhere)
make test

# Synthesis to IHP cells
IHP_PDK=~/IHP-Open-PDK make synth

# Gate-level simulation
IHP_PDK=~/IHP-Open-PDK make test_gl</code></pre>
  <div class="box box-green">
    <p>Expected output:</p>
    <pre><code>  RESULTS: 51 / 51 passed
  ✓ ALL TESTS PASSED</code></pre>
  </div>
</section>

<!-- ============================================================ -->
<!-- HANDS-ON CHALLENGES -->
<!-- ============================================================ -->
<section class="section-slide">
  <h1>Hands-On Challenges</h1>
</section>

<section>
  <h2>Challenge 1: Decode by Hand</h2>
  <div class="box box-blue">
    <p>What do these instructions do?</p>
    <table>
      <tr><th>Binary</th><th>Hex</th><th>Mnemonic?</th><th>Effect?</th></tr>
      <tr><td>0001 1010</td><td>0x1A</td><td class="fragment">LDI 10</td><td class="fragment">A = 10</td></tr>
      <tr><td>0011 0011</td><td>0x33</td><td class="fragment">SUB 3</td><td class="fragment">A = A - 3</td></tr>
      <tr><td>1101 0001</td><td>0xD1</td><td class="fragment">JNZ 1</td><td class="fragment">if A!=0: goto 1</td></tr>
      <tr><td>0110 1111</td><td>0x6F</td><td class="fragment">XOR 15</td><td class="fragment">A = A ^ 0xF</td></tr>
      <tr><td>1011 0101</td><td>0xB5</td><td class="fragment">JZ 5</td><td class="fragment">if A==0: goto 5</td></tr>
    </table>
  </div>
</section>

<section>
  <h2>Challenge 2: Write a Program</h2>
  <div class="box box-green">
    <p><strong>Task:</strong> Write a program that:</p>
    <ol>
      <li>Loads the value 8</li>
      <li>Subtracts 1 in a loop until zero</li>
      <li>Halts</li>
    </ol>
    <p class="small">Fill in the table:</p>
    <table style="font-size: 0.6em;">
      <tr><th>Addr</th><th>ASM</th><th>Hex</th></tr>
      <tr><td>0x0</td><td class="fragment">LDI 8</td><td class="fragment">0x18</td></tr>
      <tr><td>0x1</td><td class="fragment">SUB 1</td><td class="fragment">0x31</td></tr>
      <tr><td>0x2</td><td class="fragment">JNZ 1</td><td class="fragment">0xD1</td></tr>
      <tr><td>0x3</td><td class="fragment">HLT</td><td class="fragment">0xF0</td></tr>
    </table>
  </div>
</section>

<section>
  <h2>Challenge 3: Bit Manipulation</h2>
  <div class="box" style="border-color: #d29922;">
    <p><strong>Task:</strong> Write a program that:</p>
    <ol>
      <li>Loads the value 5 (binary: 0101)</li>
      <li>XORs with 15 (binary: 1111) to invert all bits</li>
      <li>Expected result: 10 (binary: 1010)</li>
      <li>Halts</li>
    </ol>
    <p class="small">Fill in the table:</p>
    <table style="font-size: 0.6em;">
      <tr><th>Addr</th><th>ASM</th><th>Hex</th><th>ACC</th></tr>
      <tr><td>0x0</td><td class="fragment">LDI 5</td><td class="fragment">0x15</td><td class="fragment">0101</td></tr>
      <tr><td>0x1</td><td class="fragment">XOR 15</td><td class="fragment">0x6F</td><td class="fragment">1010</td></tr>
      <tr><td>0x2</td><td class="fragment">HLT</td><td class="fragment">0xF0</td><td class="fragment">—</td></tr>
    </table>
    <p class="tiny fragment">Bonus: XOR with 0xF is the same as NOT! Why does our CPU have both?</p>
  </div>
</section>

<section>
  <h2>Challenge 4: Add a Test</h2>
  <div class="box box-blue">
    <p><strong>Task:</strong> Open <code>test/tb.v</code> and add a new test suite:</p>
    <pre><code class="language-verilog" style="font-size: 0.7em;">// Test 7: Your countdown program!
rom[0] = 8'h18;   // LDI 8
rom[1] = 8'h31;   // SUB 1
rom[2] = 8'hD1;   // JNZ 1
rom[3] = 8'hF0;   // HLT

// Run and check
// ... add your assertions here ...</code></pre>
    <p class="small">Run <code>make test</code> to verify!</p>
  </div>
</section>

<section>
  <h2>Challenge 5: Modify the CPU!</h2>
  <div class="box box-green">
    <p><strong>Advanced:</strong> Add a new instruction to the CPU!</p>
    <p class="small">Ideas:</p>
    <ul class="small">
      <li>Replace NOP (opcode 0) with <strong>INC</strong> (A = A + 1)</li>
      <li>Add a <strong>DEC</strong> instruction (A = A - 1)</li>
      <li>Add a <strong>NEG</strong> instruction (A = -A, two's complement)</li>
    </ul>
    <p class="small" style="margin-top: 12px;">Steps:</p>
    <ol class="small">
      <li>Edit <code>src/cpu_core.v</code> — add the case in the ALU</li>
      <li>Add a test in <code>test/tb.v</code></li>
      <li>Run <code>make test</code> to verify RTL</li>
      <li>Run <code>make synth</code> — check the cell count changed</li>
      <li>Run <code>make test_gl</code> — verify gate-level too!</li>
    </ol>
  </div>
</section>

<!-- ============================================================ -->
<!-- SUMMARY -->
<!-- ============================================================ -->
<section class="section-slide">
  <h1>Wrap-Up</h1>
</section>

<section>
  <h2>What We Built</h2>
  <div class="two-col">
    <div>
      <div class="box box-blue">
        <h3>Nibble CPU</h3>
        <ul class="small">
          <li>4-bit accumulator architecture</li>
          <li>16-instruction ISA</li>
          <li>2-cycle fetch-execute pipeline</li>
          <li>Carry and zero flags</li>
          <li>Conditional branches</li>
          <li>External I/O</li>
        </ul>
      </div>
    </div>
    <div>
      <div class="box box-green">
        <h3>Implementation</h3>
        <ul class="small">
          <li>219 lines of Verilog</li>
          <li>194 IHP SG13G2 cells</li>
          <li>20 flip-flops + 174 gates</li>
          <li>2,677 um² (15% of tile)</li>
          <li>51/51 tests pass (RTL + GL)</li>
          <li>Ready for fabrication!</li>
        </ul>
      </div>
    </div>
  </div>
</section>

<section>
  <h2>Key Takeaways</h2>
  <ol>
    <li class="fragment"><strong>CPUs are simple at heart</strong> — fetch, decode, execute, repeat</li>
    <li class="fragment"><strong>Verilog describes hardware</strong> — think wires and registers, not code</li>
    <li class="fragment"><strong>Simulation before silicon</strong> — always verify before you fabricate</li>
    <li class="fragment"><strong>Standard cells are LEGO blocks</strong> — NANDs, NORs, DFFs build anything</li>
    <li class="fragment"><strong>Open-source silicon is real</strong> — anyone can tape out a chip today</li>
  </ol>
</section>

<section>
  <h2>Resources</h2>
  <div class="box">
    <ul>
      <li><strong>This project:</strong> <a href="https://github.com/fidel-makatia/Tinytapeout_4bitCPU">github.com/fidel-makatia/Tinytapeout_4bitCPU</a></li>
      <li><strong>TinyTapeout:</strong> <a href="https://tinytapeout.com">tinytapeout.com</a></li>
      <li><strong>IHP PDK:</strong> <a href="https://github.com/IHP-GmbH/IHP-Open-PDK">github.com/IHP-GmbH/IHP-Open-PDK</a></li>
      <li><strong>Yosys:</strong> <a href="https://github.com/YosysHQ/yosys">github.com/YosysHQ/yosys</a></li>
      <li><strong>Icarus Verilog:</strong> <a href="https://github.com/steveicarus/iverilog">github.com/steveicarus/iverilog</a></li>
      <li><strong>OpenLane:</strong> <a href="https://github.com/efabless/openlane2">github.com/efabless/openlane2</a></li>
    </ul>
  </div>
</section>

<section data-background-gradient="linear-gradient(135deg, #0d1117, #161b22)">
  <h1>Thank You!</h1>
  <p style="font-size: 1.4em; margin-top: 1em;">Now let's build a CPU.</p>
  <br>
  <p class="small">
    <a href="https://github.com/fidel-makatia/Tinytapeout_4bitCPU">github.com/fidel-makatia/Tinytapeout_4bitCPU</a>
  </p>
  <p class="tiny" style="color: #8b949e; margin-top: 2em;">
    Fidel Makatia &bull; TinyTapeout IHP Workshop
  </p>
</section>

</div><!-- /slides -->
</div><!-- /reveal -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.1.0/reveal.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.1.0/plugin/highlight/highlight.min.js"></script>
<script>
Reveal.initialize({
  hash: true,
  slideNumber: true,
  transition: 'slide',
  plugins: [ RevealHighlight ],
  width: 1280,
  height: 720,
  margin: 0.04,
  center: true,
});
</script>
</body>
</html>
